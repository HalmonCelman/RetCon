////////////////////////////////////////////////////////
LLL description - by KK - All rights reserved
////////////////////////////////////////////////////////
-> LLL have memory adressed by 32 bits - up to 4GB
-> Number of command is adressed by 8bit unsigned integer from 0 to 255 - !command 58 is reserved as label! (':' in ascii)
-> Number of label is adressed by 32bit unsigned integer from 0 to 4 294 967 295

-> Labels from 0 to Flabel_number-1 are fast labels(stored in MCU), others are slow labels(on external memory)

-> All registers are 8-bit

-> FastMeM( Fast Memory Matrix - located in MCU) is from 0 adress (&0) to FastMeM_Size(LLL_FAST_MEM_SIZE)-1
FastMeM_SIZE can be set in LLL_config.h

-> SlowMeM( Slow Memory Matrix - on external memory driver ) is from FastMeM_SIZE adress to 0xFFFFFFFF

-> flags are 1 byte universal registers:
0. 	O Flag - Overflow flag, sets when overflow occure 
1. 	A Flag - additional flag - for additional information
2. 	R Flag - rest and result flag,8 older bits of multiplying, rest of dividing and result of comparing

How to write:
Flag:
 %(Flag) f.e. %O, %M, %R

Register:

&(Register Adress)
f.e
&0
&1
...

Labels:

:(labelnumber)
f.e.
:0
:1
...

Additional:
You can write *REG insted of &REG beforeÂ register adress,
 it means for parser that adress of register is stored in 4 bytes beginning from *REG
(LLL memory is stored in 32 bits format)

Avialibe commands:
Form:
(symbolic name) 	(number of command)
(functional description)
	(parameters)
(output description)

							ADD
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
ADD 	0	
Add registers
	INT,REG
Output on first REG normal: O=0,If OVF then O flag=255, and REG have OVF value so REG+%O is the answer(if it's not double overflow, if it is then REG have rest from divide of 256(8 bit registers))
INT is the number of registers used in adding - registers should be one after another
In this case you can always check if OVF occured just by checking if it's 0 or not
*****************************************************************************************************************************
ADDI 	1
Add register and integer
	REG,INT
Output on first REG normal: O=0,If OVF then O flag=255, and REG have OVF value so REG+%O is the answer
*****************************************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							SUB
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
SUB 	2
Substract registers from first one
	INT,REG
Output on first REG normal: O=0, if lower than 0 then O flag is set to the substraction result REG=0, if lower than -255 REG=substraction on minus
f.e SUB 3, (registers value)0,255,128 = -383 so O=255 and REG=128  
INT is the number of registers used in substracting - registers should be one after another
*****************************************************************************************************************************
SUBI 	3
Substract integer from register
	REG,INT
Output on first REG normal: O=0, if lower than 0 then O flag is set to the substraction result REG=0, if lower than -255 REG=substraction on minus
*****************************************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							MUL
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
MUL		4
Multiplies values from registers
	INT,REG
Output: most important part is in R(older 8 bits), second part is in first REG
as in ADD and SUB
*****************************************************************************************************************************
MULI	5
Multiplies register by integer
	REG,INT
Output: most important part is in R(older 8 bits), second part is in first REG
*****************************************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							DIV
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
DIV		6
Divide with rest register by registers
	INT,REG
Output of division is in first REG, rest of division is in R Flag
*****************************************************************************************************************************
DIVI	7
Divide with rest register by integer
	REG,INT
Output of division is in first REG, rest of division is in R Flag
*****************************************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							AND
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
AND		8
Logic AND operation between registers
	INT,REG
Output on first REG
*****************************************************************************************************************************
ANDI	9
Logic AND operation between register and integer
	REG,INT
Output on first REG
*****************************************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							OR
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*****************************************************************************************************************************
OR		10
Logic OR operation between registers
	INT,REG
Output on first REG
*****************************************************************************************************************************
ORI		11
Logic OR operation between register and integer
	REG,INT
Output on first REG
*****************************************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NOT		12
logic negate of Register
	REG
Output in REG
*****************************************************************************************************************************
INC		13
Increment value in register
	REG
Output: value incremented by 1 in this register if OVF occure then O flag is set and REG=0
*****************************************************************************************************************************
DEC		14
Decrement value in register
	REG
Output on REG, when result is -1 then REG=0 and M=1
*****************************************************************************************************************************
SER		15
Sets value in registers to value of another registers
	INT,REG1,REG2
REG1 is adress to int series, REG2 also
REG1=REG2			--\
REG1+1=REG2+1		  | INT times
...					  | 
REG1+INT-1=REG2+INT-1-/
*****************************************************************************************************************************
SERI	16
Sets value in register to integer
	INT,REG,INT
Same as SER but INTs instead of REG2...
*****************************************************************************************************************************
LJMP	17
Jump to some label;
	(labelnumber)
There is no output
*****************************************************************************************************************************
JMP		18
It's an absolute jump to the offset of file
	adress(32 bits value)
There is no output
*****************************************************************************************************************************
CMP		19
Compare two registers
	REG,REG
Output: %R= if equal:1 ; if lower: 0; if greater: 2
*****************************************************************************************************************************
CMPI		20
Compare register and integer
	REG,INT
Output: %R= if equal:1 ; if lower: 0; if greater: 2
*****************************************************************************************************************************
SEQ		21
Skip next command if equal( if R flag=1 )
	(no arguments)
no output
*****************************************************************************************************************************
DEQ		22
Do next command if equal( if R flag=1 )
	(no arguments)
no output
*****************************************************************************************************************************
SLO 	23
Skip next command if lower( if R flag=0 )
	(no arguments)
no output
*****************************************************************************************************************************
DLO		24
Do next command if lower( if R flag=0 )
	(no arguments)
no output
*****************************************************************************************************************************
SGR		25
Skip next command if greater( if R flag=2 )
	(no arguments)
no output
*****************************************************************************************************************************
DGR		26
Do next command if greater( if R flag=2 )
	(no arguments)
no output
*****************************************************************************************************************************
IN		27
Get standard input( how many bytes and first REG), information from which stream you can give by M flag
	REG
Output is in &REG, &(REG+1), &(REG+2), ...- number of bytes readed depends on wchich stream you select
*****************************************************************************************************************************
OUT		28
Give informations to standard output (how many bytes and first REG), information to which stream you can give by A flag
	REG
Information given to standard output is in &REG, &(REG+1), &(REG+2), ...- number of bytes written depends on wchich stream you select
*****************************************************************************************************************************
If command returned = 255 it means that end of program has been reached

